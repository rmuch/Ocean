/// Core module of the Ocean web framework, managing routing.
module Ocean.Core

open System
open System.IO
open System.Net
open System.Text.RegularExpressions

/// Takes a Response (or any type 'E) and returns a RequestHandler (or any
/// genericized function of 'P -> 'E), discarding the parameter 'P and
/// returning 'E.
let ignoreRequest<'E, 'P> (e : 'E) (_ : 'P) : 'E = e
let internal ignoreFirst = ignoreRequest

/// Dictionary of HTTP status codes and their string descriptions.
let internal httpStatusCodes =
    dict [ 200, "OK"
           201, "Created"
           202, "Accepted"
           203, "Non-Authoritative Information"
           204, "No Content"
           205, "Reset Content"
           206, "Partial Content"

           300, "Multiple Choices"
           301, "Moved Permanently"
           302, "Found"
           303, "See Other"
           304, "Not Modified"
           307, "Temporary Redirect"
           308, "Permanent Redirect"

           400, "Bad Request"
           401, "Unauthorized"
           402, "Payment Required"
           403, "Forbidden"
           404, "Not Found"
           410, "Gone"
           418, "I'm a teapot"

           500, "Internal Server Error"
           501, "Not Implemented" ]

/// Type representing a HTTP cookie received from or about to be sent in
/// response to a request.
type Cookie =
    { /// Cookie name.
      Name : string
      /// Cookie value.
      Value : string
      /// Cookie expiry date.
      Expiry : DateTime }

/// Type representing a HTTP request received from a client and ready to be
/// processed by a RequestHandler.
type Request =
    { /// HTTP request verb.
      Verb : string
      /// Target URL.
      Url : Uri
      /// HTTP headers.
      Headers : (string * string list) list
      /// Cookies.
      Cookies : Cookie list
      /// Body reader.
      BodyReader : unit -> StreamReader
      /// IP address and port of the request origin.
      RemoteEndPoint : IPEndPoint
      /// Set of match parameters generated by the route's RouteMatcher before
      /// being routed to the final RequestHandler.
      MatchParameters : (string * string) list }
    /// An empty request definition.
    static member empty =
        { Verb = ""
          Url = null
          Headers = []
          Cookies = []
          BodyReader = null |> ignoreFirst
          RemoteEndPoint = null
          MatchParameters = [] }

/// Type representing a HTTP response to be generated by a RequestHandler.
type Response =
    { /// Numeric HTTP status code, e.g. 200 (OK).
      StatusCode : int
      /// Message string for a HTTP status code, e.g. "OK" for 200.
      StatusMessage : string
      /// HTTP headers.
      Headers : (string * string list) list
      /// Cookies.
      Cookies : Cookie list
      /// Body writer.
      BodyWriter : TextWriter -> unit }
    /// A default, empty response definition serving 200 OK and no content.
    static member empty =
        { StatusCode = 200
          StatusMessage = "OK"
          Headers = []
          Cookies = []
          BodyWriter = () |> ignoreFirst }
    /// A default, empty response definition serving 200 OK and no content.
    static member ok = Response.empty
    /// A response to serve an error code.
    static member error (code : int) =
        let writer (w : TextWriter) =
            w.WriteLine(Ocean.Resources.internalPageStart)
            w.WriteLine("<h1>{0} {1}</h1>", code, httpStatusCodes.Item code)
            w.WriteLine(Ocean.Resources.internalPageEnd)
        { Response.empty with StatusCode = code; StatusMessage = httpStatusCodes.Item code; BodyWriter = writer }

/// Result type for a RouteMatcher predicate function, representing either a
/// successful match with optional list parameters, or a failure to provide
/// a match.
type MatchResult =
    | Success of (string * string) list
    | Failure

/// Predicate function type to associate a request with a route, accepting a
/// HTTP request as a parameter and returning a boolean value indicating a
/// successful match.
type RouteMatcher = Request -> MatchResult

/// Function signature of a request handler, accpeting a request parameter and
/// returning a response to be written to the client.
type RequestHandler = Request -> Response

/// Tuple of a route match predicate and a request handler.
type Route = RouteMatcher * RequestHandler

/// List of pairs of route matchers and request handlers.
type RouteList = Route list

/// Basic URL-matching predicate functions.
[<RequireQualifiedAccess>]
module Match =
    /// Match a path exactly.
    let path (path : string) (req : Request) : MatchResult =
        if req.Url.AbsolutePath = path then Success [] else Failure
    /// Match a path with a specific prefix.
    let prefix (path : string) (req : Request) : MatchResult =
        if req.Url.AbsolutePath.StartsWith(path) then Success [] else Failure
    /// Match by regular expression.
    let regex (pattern : string) (req : Request) : MatchResult =
        let rgx = Regex.Match(req.Url.AbsolutePath, pattern)
        if rgx.Success then Success [] else Failure

/// Helper functions for quick responses.
[<RequireQualifiedAccess>]
module RespondWith =
    /// Generate a response serving a string.
    let str (s : string) : Response =
        { Response.ok with BodyWriter = fun w -> w.Write(s) }
    /// Generate a response serving a file.
    let file (path : string) : Response =
        { Response.ok with BodyWriter = fun w -> w.Write(File.ReadAllText(path)) }
    /// Generate a response serving a default page for a HTTP error code.
    let err (err : int) : Response =
        Response.error err
    /// Generate a response serving a default page for an exception and stack trace.
    let exn (ex : exn) : Response =
        let exnWriter (w : TextWriter) =
            w.WriteLine(Ocean.Resources.internalPageStart);
            w.WriteLine("<h1>{0}</h1>", ex.Message)
            w.WriteLine("""<code class="ocean-stack-trace"><pre>{0}</pre></code>""", ex.ToString())
            w.WriteLine(Ocean.Resources.internalPageEnd);
        { Response.error 500 with BodyWriter = exnWriter }

/// Resolve a Request to a RequestHandler, also providing the result of the RouteMatcher function.
let rec resolveRoute (route : RouteList)
                     (notFoundHandler : RequestHandler)
                     (req : Request) : RequestHandler * MatchResult =
    match route with
    | head :: tail ->
        match req |> fst head with
        | Success res -> snd head, Success res
        | Failure -> resolveRoute tail notFoundHandler req
    | [] -> notFoundHandler, Failure
